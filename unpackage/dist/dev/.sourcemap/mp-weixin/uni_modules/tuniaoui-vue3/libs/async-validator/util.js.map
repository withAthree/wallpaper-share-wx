{"version":3,"file":"util.js","sources":["uni_modules/tuniaoui-vue3/libs/async-validator/util.ts"],"sourcesContent":["/* eslint no-console:0 */\n\nimport type {\n  ValidateError,\n  ValidateOption,\n  RuleValuePackage,\n  InternalRuleItem,\n  SyncErrorType,\n  RuleType,\n  Value,\n  Values,\n} from './interface';\n\nconst formatRegExp = /%[sdj%]/g;\n\ndeclare var ASYNC_VALIDATOR_NO_WARNING;\n\nexport let warning: (type: string, errors: SyncErrorType[]) => void = () => {};\n\n// don't print warning message when in production env or node runtime\nif (\n  typeof process !== 'undefined' &&\n  process.env &&\n  process.env.NODE_ENV !== 'production' &&\n  typeof window !== 'undefined' &&\n  typeof document !== 'undefined'\n) {\n  warning = (type, errors) => {\n    if (\n      typeof console !== 'undefined' &&\n      console.warn &&\n      typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined'\n    ) {\n      if (errors.every(e => typeof e === 'string')) {\n        console.warn(type, errors);\n      }\n    }\n  };\n}\n\nexport function convertFieldsError(\n  errors: ValidateError[],\n): Record<string, ValidateError[]> {\n  if (!errors || !errors.length) return null;\n  const fields = {};\n  errors.forEach(error => {\n    const field = error.field;\n    fields[field] = fields[field] || [];\n    fields[field].push(error);\n  });\n  return fields;\n}\n\nexport function format(\n  template: ((...args: any[]) => string) | string,\n  ...args: any[]\n): string {\n  let i = 0;\n  const len = args.length;\n  if (typeof template === 'function') {\n    return template.apply(null, args);\n  }\n  if (typeof template === 'string') {\n    let str = template.replace(formatRegExp, x => {\n      if (x === '%%') {\n        return '%';\n      }\n      if (i >= len) {\n        return x;\n      }\n      switch (x) {\n        case '%s':\n          return String(args[i++]);\n        case '%d':\n          return (Number(args[i++]) as unknown) as string;\n        case '%j':\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return '[Circular]';\n          }\n          break;\n        default:\n          return x;\n      }\n    });\n    return str;\n  }\n  return template;\n}\n\nfunction isNativeStringType(type: string) {\n  return (\n    type === 'string' ||\n    type === 'url' ||\n    type === 'hex' ||\n    type === 'email' ||\n    type === 'date' ||\n    type === 'pattern'\n  );\n}\n\nexport function isEmptyValue(value: Value, type?: string) {\n  if (value === undefined || value === null) {\n    return true;\n  }\n  if (type === 'array' && Array.isArray(value) && !value.length) {\n    return true;\n  }\n  if (isNativeStringType(type) && typeof value === 'string' && !value) {\n    return true;\n  }\n  return false;\n}\n\nexport function isEmptyObject(obj: object) {\n  return Object.keys(obj).length === 0;\n}\n\nfunction asyncParallelArray(\n  arr: RuleValuePackage[],\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n) {\n  const results: ValidateError[] = [];\n  let total = 0;\n  const arrLength = arr.length;\n\n  function count(errors: ValidateError[]) {\n    results.push(...(errors || []));\n    total++;\n    if (total === arrLength) {\n      callback(results);\n    }\n  }\n\n  arr.forEach(a => {\n    func(a, count);\n  });\n}\n\nfunction asyncSerialArray(\n  arr: RuleValuePackage[],\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n) {\n  let index = 0;\n  const arrLength = arr.length;\n\n  function next(errors: ValidateError[]) {\n    if (errors && errors.length) {\n      callback(errors);\n      return;\n    }\n    const original = index;\n    index = index + 1;\n    if (original < arrLength) {\n      func(arr[original], next);\n    } else {\n      callback([]);\n    }\n  }\n\n  next([]);\n}\n\nfunction flattenObjArr(objArr: Record<string, RuleValuePackage[]>) {\n  const ret: RuleValuePackage[] = [];\n  Object.keys(objArr).forEach(k => {\n    ret.push(...(objArr[k] || []));\n  });\n  return ret;\n}\n\nexport class AsyncValidationError extends Error {\n  errors: ValidateError[];\n  fields: Record<string, ValidateError[]>;\n\n  constructor(\n    errors: ValidateError[],\n    fields: Record<string, ValidateError[]>,\n  ) {\n    super('Async Validation Error');\n    this.errors = errors;\n    this.fields = fields;\n  }\n}\n\ntype ValidateFunc = (\n  data: RuleValuePackage,\n  doIt: (errors: ValidateError[]) => void,\n) => void;\n\nexport function asyncMap(\n  objArr: Record<string, RuleValuePackage[]>,\n  option: ValidateOption,\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n  source: Values,\n): Promise<Values> {\n  if (option.first) {\n    const pending = new Promise<Values>((resolve, reject) => {\n      const next = (errors: ValidateError[]) => {\n        callback(errors);\n        return errors.length\n          ? reject(new AsyncValidationError(errors, convertFieldsError(errors)))\n          : resolve(source);\n      };\n      const flattenArr = flattenObjArr(objArr);\n      asyncSerialArray(flattenArr, func, next);\n    });\n    pending.catch(e => e);\n    return pending;\n  }\n  const firstFields =\n    option.firstFields === true\n      ? Object.keys(objArr)\n      : option.firstFields || [];\n\n  const objArrKeys = Object.keys(objArr);\n  const objArrLength = objArrKeys.length;\n  let total = 0;\n  const results: ValidateError[] = [];\n  const pending = new Promise<Values>((resolve, reject) => {\n    const next = (errors: ValidateError[]) => {\n      results.push.apply(results, errors);\n      total++;\n      if (total === objArrLength) {\n        callback(results);\n        return results.length\n          ? reject(\n              new AsyncValidationError(results, convertFieldsError(results)),\n            )\n          : resolve(source);\n      }\n    };\n    if (!objArrKeys.length) {\n      callback(results);\n      resolve(source);\n    }\n    objArrKeys.forEach(key => {\n      const arr = objArr[key];\n      if (firstFields.indexOf(key) !== -1) {\n        asyncSerialArray(arr, func, next);\n      } else {\n        asyncParallelArray(arr, func, next);\n      }\n    });\n  });\n  pending.catch(e => e);\n  return pending;\n}\n\nfunction isErrorObj(\n  obj: ValidateError | string | (() => string),\n): obj is ValidateError {\n  return !!(obj && (obj as ValidateError).message !== undefined);\n}\n\nfunction getValue(value: Values, path: string[]) {\n  let v = value;\n  for (let i = 0; i < path.length; i++) {\n    if (v == undefined) {\n      return v;\n    }\n    v = v[path[i]];\n  }\n  return v;\n}\n\nexport function complementError(rule: InternalRuleItem, source: Values) {\n  return (oe: ValidateError | (() => string) | string): ValidateError => {\n    let fieldValue;\n    if (rule.fullFields) {\n      fieldValue = getValue(source, rule.fullFields);\n    } else {\n      fieldValue = source[(oe as any).field || rule.fullField];\n    }\n    if (isErrorObj(oe)) {\n      oe.field = oe.field || rule.fullField;\n      oe.fieldValue = fieldValue;\n      return oe;\n    }\n    return {\n      message: typeof oe === 'function' ? oe() : oe,\n      fieldValue,\n      field: ((oe as unknown) as ValidateError).field || rule.fullField,\n    };\n  };\n}\n\nexport function deepMerge<T extends object>(target: T, source: Partial<T>): T {\n  if (source) {\n    for (const s in source) {\n      if (source.hasOwnProperty(s)) {\n        const value = source[s];\n        if (typeof value === 'object' && typeof target[s] === 'object') {\n          target[s] = {\n            ...target[s],\n            ...value,\n          };\n        } else {\n          target[s] = value;\n        }\n      }\n    }\n  }\n  return target;\n}\n"],"names":["warning","uni"],"mappings":";;AAaA,MAAM,eAAe;AAIVA,QAAAA,UAA2D,MAAA;AAAO;AAG7E,IACE,OAAO,YAAY,eACnB,QAAQ,OACR,QACA,OAAO,WAAW,eAClB,OAAO,aAAa,aACpB;AACUA,oBAAA,CAAC,MAAM,WAAM;AACrB,QACE,OAAO,YAAY,eACnB,QAAQ,QACR,OAAO,+BAA+B,aACtC;AACI,UAAA,OAAO,MAAM,CAAK,MAAA;AAAA,eAAA,OAAO,MAAM;AAAA,MAAA,CAAQ,GAAG;AAC5CC,sBAAA,oFAAa,MAAM,MAAM;AAAA,MAC1B;AAAA,IACF;AAAA,EAAA;AAEJ;AAEK,SAAU,mBACd,QAAuB;AAEnB,MAAA,CAAC,UAAU,CAAC,OAAO;AAAe,WAAA;AACtC,QAAM,SAAS,CAAA;AACf,SAAO,QAAQ,CAAK,UAAA;AAClB,UAAM,QAAQ,MAAM;AACpB,WAAO,KAAK,IAAI,OAAO,KAAK,KAAK,CAAA;AAC1B,WAAA,KAAK,EAAE,KAAK,KAAK;AAAA,EAAA,CACzB;AACM,SAAA;AACT;AAEgB,SAAA,OACd,aACG,MAAW;AAEd,MAAI,IAAI;AACR,QAAM,MAAM,KAAK;AACb,MAAA,OAAO,aAAa,YAAY;AAC3B,WAAA,SAAS,MAAM,MAAM,IAAI;AAAA,EACjC;AACG,MAAA,OAAO,aAAa,UAAU;AAChC,QAAI,MAAM,SAAS,QAAQ,cAAc,CAAC,MAAA;AACxC,UAAI,MAAM,MAAM;AACP,eAAA;AAAA,MACR;AACD,UAAI,KAAK,KAAK;AACL,eAAA;AAAA,MACR;AACD,cAAQ,GAAG;AAAA,QACT,KAAK;AACI,iBAAA,OAAO,KAAK,GAAG,CAAC;AAAA,QACzB,KAAK;AACK,iBAAA,OAAO,KAAK,GAAG,CAAC;AAAA,QAC1B,KAAK;AACC,cAAA;AACF,mBAAO,KAAK,UAAU,KAAK,GAAG,CAAC;AAAA,mBACxB,GAAG;AACH,mBAAA;AAAA,UACR;AACD;AAAA,QACF;AACS,iBAAA;AAAA,MACV;AAAA,IAAA,CACF;AACM,WAAA;AAAA,EACR;AACM,SAAA;AACT;AAEA,SAAS,mBAAmB,MAAY;AAEpC,SAAA,SAAS,YACT,SAAS,SACT,SAAS,SACT,SAAS,WACT,SAAS,UACT,SAAS;AAEb;AAEgB,SAAA,aAAa,OAAc,MAAa;AAClD,MAAA,UAAU,UAAa,UAAU,MAAM;AAClC,WAAA;AAAA,EACR;AACG,MAAA,SAAS,WAAW,MAAM,QAAQ,KAAK,KAAK,CAAC,MAAM,QAAQ;AACtD,WAAA;AAAA,EACR;AACD,MAAI,mBAAmB,IAAI,KAAK,OAAO,UAAU,YAAY,CAAC,OAAO;AAC5D,WAAA;AAAA,EACR;AACM,SAAA;AACT;AAMA,SAAS,mBACP,KACA,MACA,UAA2C;AAE3C,QAAM,UAA2B,CAAA;AACjC,MAAI,QAAQ;AACZ,QAAM,YAAY,IAAI;AAEtB,WAAS,MAAM,QAAuB;AACpC,YAAQ,KAAK,GAAI,UAAU,CAAG,CAAA;AAC9B;AACA,QAAI,UAAU,WAAW;AACvB,eAAS,OAAO;AAAA,IACjB;AAAA,EACH;AAEA,MAAI,QAAQ,CAAC,MAAA;AACX,SAAK,GAAG,KAAK;AAAA,EAAA,CACd;AACH;AAEA,SAAS,iBACP,KACA,MACA,UAA2C;AAE3C,MAAI,QAAQ;AACZ,QAAM,YAAY,IAAI;AAEtB,WAAS,KAAK,QAAuB;AAC/B,QAAA,UAAU,OAAO,QAAQ;AAC3B,eAAS,MAAM;AACf;AAAA,IACD;AACD,UAAM,WAAW;AACjB,YAAQ,QAAQ;AAChB,QAAI,WAAW,WAAW;AACnB,WAAA,IAAI,QAAQ,GAAG,IAAI;AAAA,IAAA,OACnB;AACL,eAAS,CAAE,CAAA;AAAA,IACZ;AAAA,EACH;AAEA,OAAK,CAAE,CAAA;AACT;AAEA,SAAS,cAAc,QAA0C;AAC/D,QAAM,MAA0B,CAAA;AAChC,SAAO,KAAK,MAAM,EAAE,QAAQ,CAAC,MAAA;AAC3B,QAAI,KAAK,GAAI,OAAO,CAAC,KAAK,CAAG,CAAA;AAAA,EAAA,CAC9B;AACM,SAAA;AACT;AAEM,MAAO,6BAA6B,MAAK;AAAA,EAI7C,YACE,QACA,QAAuC;AAEvC,UAAM,wBAAwB;AAC9B,SAAK,SAAS;AACd,SAAK,SAAS;AAAA,EAChB;AACD;AAOK,SAAU,SACd,QACA,QACA,MACA,UACA,QAAc;AAEd,MAAI,OAAO,OAAO;AAChB,UAAM,YAAU,IAAI,QAAgB,CAAC,SAAS,WAAM;AAC5C,YAAA,OAAO,CAAC,WAAuB;AACnC,iBAAS,MAAM;AACf,eAAO,OAAO,SACV,OAAO,IAAI,qBAAqB,QAAQ,mBAAmB,MAAM,CAAC,CAAC,IACnE,QAAQ,MAAM;AAAA,MAAA;AAEd,YAAA,aAAa,cAAc,MAAM;AACtB,uBAAA,YAAY,MAAM,IAAI;AAAA,IAAA,CACxC;AACD,cAAQ,MAAM,CAAC,MAAA;AAAI,aAAA;AAAA,IAAA,CAAC;AACb,WAAA;AAAA,EACR;AACK,QAAA,cACJ,OAAO,gBAAgB,OACnB,OAAO,KAAK,MAAM,IAClB,OAAO,eAAe,CAAA;AAEtB,QAAA,aAAa,OAAO,KAAK,MAAM;AACrC,QAAM,eAAe,WAAW;AAChC,MAAI,QAAQ;AACZ,QAAM,UAA2B,CAAA;AACjC,QAAM,UAAU,IAAI,QAAgB,CAAC,SAAS,WAAM;AAC5C,UAAA,OAAO,CAAC,WAAuB;AAC3B,cAAA,KAAK,MAAM,SAAS,MAAM;AAClC;AACA,UAAI,UAAU,cAAc;AAC1B,iBAAS,OAAO;AAChB,eAAO,QAAQ,SACX,OACE,IAAI,qBAAqB,SAAS,mBAAmB,OAAO,CAAC,CAAC,IAEhE,QAAQ,MAAM;AAAA,MACnB;AAAA,IAAA;AAEC,QAAA,CAAC,WAAW,QAAQ;AACtB,eAAS,OAAO;AAChB,cAAQ,MAAM;AAAA,IACf;AACD,eAAW,QAAQ,CAAG,QAAA;AACd,YAAA,MAAM,OAAO,GAAG;AACtB,UAAI,YAAY,QAAQ,GAAG,MAAM,IAAI;AAClB,yBAAA,KAAK,MAAM,IAAI;AAAA,MAAA,OAC3B;AACc,2BAAA,KAAK,MAAM,IAAI;AAAA,MACnC;AAAA,IAAA,CACF;AAAA,EAAA,CACF;AACD,UAAQ,MAAM,CAAC,MAAA;AAAI,WAAA;AAAA,EAAA,CAAC;AACb,SAAA;AACT;AAEA,SAAS,WACP,KAA4C;AAE5C,SAAO,CAAC,EAAE,OAAQ,IAAsB,YAAY;AACtD;AAEA,SAAS,SAAS,OAAe,MAAc;AAC7C,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,QAAI,KAAK,QAAW;AACX,aAAA;AAAA,IACR;AACG,QAAA,EAAE,KAAK,CAAC,CAAC;AAAA,EACd;AACM,SAAA;AACT;AAEgB,SAAA,gBAAgB,MAAwB,QAAc;AACpE,SAAO,CAAC,OAA2C;AAC7C,QAAA;AACJ,QAAI,KAAK,YAAY;AACN,mBAAA,SAAS,QAAQ,KAAK,UAAU;AAAA,IAAA,OACxC;AACL,mBAAa,OAAQ,GAAW,SAAS,KAAK,SAAS;AAAA,IACxD;AACG,QAAA,WAAW,EAAE,GAAG;AACf,SAAA,QAAQ,GAAG,SAAS,KAAK;AAC5B,SAAG,aAAa;AACT,aAAA;AAAA,IACR;AACM,WAAA;AAAA,MACL,SAAS,OAAO,OAAO,aAAa,GAAO,IAAA;AAAA,MAC3C;AAAA,MACA,OAAS,GAAiC,SAAS,KAAK;AAAA,IAAA;AAAA;AAG9D;AAEgB,SAAA,UAA4B,QAAW,QAAkB;AACvE,MAAI,QAAQ;AACV,eAAW,KAAK,QAAQ;AAClB,UAAA,OAAO,eAAe,CAAC,GAAG;AACtB,cAAA,QAAQ,OAAO,CAAC;AACtB,YAAI,OAAO,UAAU,YAAY,OAAO,OAAO,CAAC,MAAM,UAAU;AAC9D,iBAAO,CAAC,IACH,OAAA,OAAA,OAAA,OAAA,CAAA,GAAA,OAAO,CAAC,CAAC,GACT,KAAK;AAAA,QAAA,OAEL;AACL,iBAAO,CAAC,IAAI;AAAA,QACb;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACM,SAAA;AACT;;;;;;;"}